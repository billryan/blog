---
date: 2015-09-04T10:44:40+08:00
title: 数组和指针
---

# 数组和指针

先从指针说起。

## 指针

### const

以下两种形式等价。

```c
const int *a;
int const *a;
```

a是一个指向const int型的指针，a所指向的内存单元不可改写，所以(*a)++是不允许的，但a可以改写，所以a++是允许的。

```c
int * const a;
```

a是一个指向int型的const指针，*a是可以改写的，但a不允许改写。

```c
int const * const a;
```

a是一个指向const int型的const指针，因此*a和a都不允许改写。

<!--more-->

### 指向数组的指针和多维数组

指针除了可以指向指针外还可以指向符合数据类型，下面写个小程序验证下数组指针和数组名等纠结的名词。

```
#include <iostream>

using namespace std;

int main(int argc, char *argv[])
{
	int a[4] = {1, 2, 3, 4};
	int *p1 = a;
	int *p2 = &a[0];
	//int *p3 = &a; // compile error: type 'int *' with an rvalue of type 'int (*)[4]'
	int (*p4)[4] = &a; // OK
	//int (*p5)[4] = a; // compile error: type 'int (*)[4]' with an lvalue of type 'int [4]'

	cout << "Address of a[0]: " << &a[0] << endl;
	cout << "Address of a:    " << &a << endl;
	cout << "Value of a:      " << a << endl;
	cout << "Value of p1:     " << p1 << endl;
	cout << "Value of p2:     " << p2 << endl;
	
	return 0;
}
```

编译运行后能发现每一行的输出都是一样的，说明如下的一些事实：

1. `&a[0]`, `&a`, `a` 三者的值都一样，都是数组第一个元素的值。
2. `int *p1 = a;` 说明数组名`a`可以作为右值使用，其值为数组首元素的值。
3. `int *p2 = &a[0]` 取数组首元素的地址，比较好理解。
4. `int *p3 = &a;` 这一句不太好懂，大多数人只知道数组名作为右值表示数组首元素的地址，但如果对数组名取地址会怎么样呢？从编译错误中我们可以看出`&a` 的类型是`int (*)[4]`, 即**数组指针**！也就是说`&a` 和作为右值的`a`的值虽然一样，但是类型却完全不一样！
5. `int (*p4)[4] = &a;` 定义的是数组指针，即指向数组的指针。`[]`比`*` 优先级更高，所以需要`(*p4)`, 表明`p4` 是一个指针。以上定义等价于首先定义一个大小为4的一维数组，随后定义新的指针类型。`typedef int t[10]; t *a;`
6. `int (*p5)[4] = a;` 再次表明数组名本身是左值，但是只能作为常量，作为右值使用时类型为`int []`

由于数组的所有元素在内存中均是连续字节存放，数组名作为数组的标识符，表示的是一组元素，故不能将数组作为右值直接读出，也不能作为左值直接赋值，故 C/C++ 中对数组名有特殊规定：

1. 作为sizeof的操作数，数组名代表数组对象本身。故使用`sizeof(a)` 表示的是整个数组占用的大小。
2. 作为取地址运算符&的操作数，数组名代表数组对象本身。因为这一点才可以执行`&a`.
3. 作为字符串字面量用于初始化一个数组。
4. 其他情形被转化为**数组首元素**的指针类型表达式(右值)。

### 数组和指针的关系

```
int a[10] <==> int * const a;
int b[3][4] <==> int (* const b)[4];
int c[3][4][5] <==> int (* const c)[4][5]
```

从中可以看出数组名是一个常量指针，且有`a[2] == *(a + 2)`, `a[3]` 的地址和`a + 3 * sizeof(int)` 的值等价。
数组名做右值时转换成指向首元素的指针，但做左值仍然表示整个数组的存储空间，而不是首元素的存储空间。

### 多维数组

多维数组通过递归都可以看作是二维数组，二维数组在 C/C++ 中按行存储。多维数组的数组名字，在表达式中自动转换为数组首元素地址值，但这个首元素实际上是去除数组下标第一维之后的数组剩余部分。

{% raw %}
```c++
#include <iostream>

using namespace std;

int main(int argc, char *argv[])
{
	char a[4][3][2] = {{{'a', 'b'}, {'c', 'd'}, {'e', 'f'}},
			   {{'g', 'h'}, {'i', 'j'}, {'k', 'l'}},
			   {{'m', 'n'}, {'o', 'p'}, {'q', 'r'}},
			   {{'s', 't'}, {'u', 'v'}, {'w', 'x'}}};

	char (*pa)[2] = &a[1][0];
	char (*ppa)[3][2] = &a[1];
	char (*ppb)[3][2] = a;

	cout << "pa: " << pa[5][1] << endl; // pa: r
	cout << "ppa: " << ppa[1][2][1] << endl; // ppa: r
	cout << "ppb: " << ppb[1][1][1] << endl; // ppb: j

	return 0;
}
```
{% endraw %}

使用数组指针的优势在于可对指针变量自增，而数组名是常量指针，无法更改。

### 指针数组

数组中的元素也可以为复合类型，比如指针。

```c
int *a[10];
int **pa = &a[0];
```

表示以上数组由10个`int *`指针构成，pa 指向a 的首元素。函数原型`int main(int argc, char *argv[])` 中`argv`是一个指向指针的指针，并不是指针数组。原型中的`char *argv[]` 和 `char **argv` 等价，之所以写成这样是表示`argv`不是指向单个指针而是指向一个指针数组的首元素。

## Reference

- 《高质量程序设计指南》第七章
- Linux C 一站式编程
- [数组 - 维基百科](https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84)